<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marys&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-29T09:30:57.941Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marys Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript的设计模式（三）———— 原型模式</title>
    <link href="http://yoursite.com/diary/javascript-design-pattern3/"/>
    <id>http://yoursite.com/diary/javascript-design-pattern3/</id>
    <published>2017-11-15T07:49:50.365Z</published>
    <updated>2017-11-29T09:30:57.941Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式在js中经常用来创建对象的一种模式，它并不是通过创建类来创建对象，而是通过克隆一个对象来创建对象。在js中没有类的概念，所以js中的面向对象编程方式基本都是使用原型模式实现的。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-原型对象"><a href="#1-原型对象" class="headerlink" title="1.原型对象"></a>1.原型对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'Marys'</span>;</div></pre></td></tr></table></figure>
<section>以上代码声明了一个新函数Preson，每一个新函数里都包含一个prototype属性（这是一个指针），这个属性指向一个对象，这就是 <strong>原型对象</strong>，这个对象包含构建该函数的一切属性和方法，其中包含一个constructor属性，该属性指向函数本身。如下图所示</section>

<p><img src="/images/b3_1_1.png" alt="Alt text"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<section>上面的代码中，person1声明为Person的实例，在类语言中就可以说，person1是Person类型，就像数字 <strong>1</strong> 是Number类型一样。但是js中没有类的概念，那么js是怎么实例化一个对象的呢？</section><br><section>首先，当一个实例对象被声明，该实例便会包含一个[[prototype]]属性（这是也一个指针），在一些浏览器中，他可以用<code>__proto__</code>属性名读取到；然后，这个[[prototype]]属性会指向他的父级的原型对象————prototype，换句话说prototype也是person1的原型对象。关系如下图所示。<br><img src="/images/b3_1_2.png" alt="Alt text"><br></section>

<h4 id="1-1-原型链"><a href="#1-1-原型链" class="headerlink" title="1.1 原型链"></a>1.1 原型链</h4><section><br><img src="/images/b3_1_3.png" alt="Alt text"><br>如上图，便是在chrome中打印person1的结果。可以看到，在person1下的 <code>__proto__</code> 属性展开后是Person的原型，其中也包含一个 <code>__proto__</code> 属性，这个原型便是指向最根部的Object原型。像这样一层包一层的结构就像是一条链子，把原型一个个连接起来，这就是原型链。当要调用一个对象或一个方法的时候，在创建的实例中找不到的话，js便会沿着这条原型链一直向下找，如果原型链中都找不到，就是undefined了。如下面的代码，打印出来的是Person中定义的<code>Marys</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">'Marys'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.name);</div></pre></td></tr></table></figure><br><br></section>

<h4 id="1-2-关于this"><a href="#1-2-关于this" class="headerlink" title="1.2 关于this"></a>1.2 关于this</h4><section>this的指向是根据<strong>执行上下文（作用域）</strong>决定的，是一个由构造函数constructor创建的对象，所以this中的属性方法并不存在原型对象中。具体this的变化过程如下：<br><ul><br>  <li>创建实例对象</li><br>  <li>将作用域赋予对象（因此this就指向了新对象）</li><br>  <li>执行构造函数中的代码，为实例对象添加属性和方法</li><br></ul><br></section>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><section>js中的原型模式实际上就是用来实现继承的一种方式，但是使用原型模式继承的属性和方法都有一个缺点：对于引用类型值得属性是会共用的。也就是说继承的属性如果是引用类型值不是独立的，当改变其中一个实例的属性值时，其他同父级的实例的该属性也是会改变。如下代码，当person1的numbers属性推入一个值，person2中的numbers值也会受影响。但是如果代码是<code>person1.numbers = [1,2,3]</code>，person2的numbers属性是不会受到影响的，因为这样相当于person1声明了一个新的属性numbers，这是属于person1自己的属性，用this关键字是能读取到的，当声明属性与<code>__proto__</code>中的属性重名的时候，会遮挡原型对象中的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.numbers.push(<span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(person2.numbers);<span class="comment">//[1,2,3,4,5]</span></div><div class="line"></div><div class="line">person1.numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(person2.numbers);<span class="comment">//[1,2,3,4,5]</span></div><div class="line"><span class="built_in">console</span>.log(person1);</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Person &#123;numbers: Array(3)&#125;</span></div><div class="line"><span class="comment">  numbers:(3) [1, 2, 3]</span></div><div class="line"><span class="comment">  __proto__:</span></div><div class="line"><span class="comment">    numbers:(5) [1, 2, 3, 4, 5]</span></div><div class="line"><span class="comment">    constructor:ƒ Person()</span></div><div class="line"><span class="comment">    __proto__:Object</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><br><br></section>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式在js中经常用来创建对象的一种模式，它并不是通过创建类来创建对象，而是通过克隆一个对象来创建对象。在js中没有类的概念，所以js中的面向对象编程方式基本都是使用原型模式实现的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript的设计模式（二）———— 设计模式原则</title>
    <link href="http://yoursite.com/diary/javascript-design-pattern2/"/>
    <id>http://yoursite.com/diary/javascript-design-pattern2/</id>
    <published>2017-08-07T09:21:45.380Z</published>
    <updated>2017-08-08T09:36:15.113Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，设计模式拥有六个原则：单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和开闭原则。然而js中没有抽象、继承、接口这些定义，故在《javascript设计模式与开发实践》一书中只提到了单一职责原则、最少知识原则（迪米特法则）和开闭原则。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><section>单一职责，顾名思义就是一个方法只做一件事。这很容易理解，也可以看看下面这段代码：</section>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//未遵循单一职责，将创建div和单例检测两个功能放在了一起</span></div><div class="line"><span class="keyword">var</span> createDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> div;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!div)&#123;  <span class="comment">//单例职责</span></div><div class="line">      div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);  <span class="comment">//创建div</span></div><div class="line">      <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> div;</div><div class="line">  &#125;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="comment">//遵循单一职责</span></div><div class="line"><span class="keyword">var</span> createSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;  <span class="comment">//单例职责</span></div><div class="line">  <span class="keyword">var</span> result;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> createDiv = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//创建div</span></div><div class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">  <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">  <span class="keyword">return</span> div;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> createSingleDiv = createSingle(createDiv);</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = createSingleDiv();</div><div class="line"><span class="keyword">var</span> div2 = createSingleDiv();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(div1 === div2); <span class="comment">//true;</span></div></pre></td></tr></table></figure>
<section>从上面是一段单例模式的代码，很清晰的表达了单一原则的意思：一个方法只做一件事。当需要修改时，程序员不需要从一大段代码中找出对应功能的代码，而且很重要的是你不能保证修改的代码没有影响到另一个功能，一旦出现bug查找起来就会非常麻烦，遵循单一原则对于代码的维护有着非常重要的作用。</section><br><section>但是单一原则的使用，一定程度上会增加代码的量。一般来说，当若干个代码的改变是同时进行的（就像websocket的connect和open几乎是一起执行的），那么就可以忽略单一原则，把他们写在一起更方便维护。</section>


<h3 id="2-最少知识原则"><a href="#2-最少知识原则" class="headerlink" title="2.最少知识原则"></a>2.最少知识原则</h3><p>最少知识原则，说白了就是对象之间的解耦，两个对象之间尽量减少内部的交流。一般的实现方法有：委托第三方（中介者模式等）和封装暴露接口调用。</p>

<h4 id="2-1封装"><a href="#2-1封装" class="headerlink" title="2.1封装"></a>2.1封装</h4><section>封装广义来说包括封装数据、封装实现、封装类型和封装变化。对于js来说并无类型限制，所以封装类型先忽略。</section><br><section>封装数据，其实就是对变量、函数的作用域进行限制，实现类似java中的sectionublish和private。如下实现：</section><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDiv</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> div;  <span class="comment">//div的作用域就被限制在createDiv里面，变成了createDiv的私有变量。</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//这个方法就被曝光给外作用域使用。</span></div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> div;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><section></section>

<h4 id="2-2封装变化"><a href="#2-2封装变化" class="headerlink" title="2.2封装变化"></a>2.2封装变化</h4><p><section>将对象中变化的部分抽取出来进行封装，这样在替换变化部分的时候就不会影响到不变化的部分。</section></p>
<h4 id="2-3封装实现"><a href="#2-3封装实现" class="headerlink" title="2.3封装实现"></a>2.3封装实现</h4><p>封装的目的就是将信息隐藏，是的对象内部的变化对其他对象是透明的，也就是不可见的。对象对自己的行为负责，对象之间通过暴露出来的API进行通信。</p>
<h3 id="3-开闭原则"><a href="#3-开闭原则" class="headerlink" title="3.开闭原则"></a>3.开闭原则</h3><p>开闭原则，就是使程序拥有扩展性，当要修改或要增加一段代码时，不必要在原来的代码上做修改。下面来介绍一下实现开闭原则的几种方式</p>

<h4 id="3-1职责链模式"><a href="#3-1职责链模式" class="headerlink" title="3.1职责链模式"></a>3.1职责链模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> _ = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = _.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> _ = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> _.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'load2'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">....<span class="comment">//一系列代码</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//在window.onload事件中添加别的行为，而不会覆盖原来的行为</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'load3'</span>);</div><div class="line">&#125;).before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'load1'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//结果: load1</span></div><div class="line"><span class="comment">//      load2</span></div><div class="line"><span class="comment">//      load3</span></div></pre></td></tr></table></figure>
<p>上面的代码使window.onload有了扩展性，在后面添加的方法并不会覆盖前面定义的代码，而是可以一并实行。把after和before两个方法用在其他方法中也是一样的，如此以来程序员在未来要添加方法的时候就不必要跑到原来的方法中修改代码，就可以避免不必要的bug发生。</p>


<h4 id="3-2对象多态"><a href="#3-2对象多态" class="headerlink" title="3.2对象多态"></a>3.2对象多态</h4><p>可以参考上一篇博客<a target="_blank" href="../javascript-design-pattern1">《javascript的设计模式（一）———— 多态》</a></p>
<h4 id="3-3回调函数"><a href="#3-3回调函数" class="headerlink" title="3.3回调函数"></a>3.3回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createDiv = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)；</div><div class="line">  cb &amp;&amp; cb();</div><div class="line">&#125;</div><div class="line"></div><div class="line">createDiv(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'create success'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//create success</span></div></pre></td></tr></table></figure>
<p>开闭原则一般来说很难100%的实现，作为程序员我们应该尽量把会发生改变的地方单独出来，方便修改。在第一次些代码的时很少可以考虑完善哪些地方需要修改，所以在着手写代码时可以先不考虑开闭原则，在后来需求比较确定之后再进行代码的完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，设计模式拥有六个原则：单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和开闭原则。然而js中没有抽象、继承、接口这些定义，故在《javascript设计模式与开发实践》一书中只提到了单一职责原则、最少知识原则（迪米特法则）和开闭原则。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript的设计模式（一）———— 多态</title>
    <link href="http://yoursite.com/diary/javascript-design-pattern1/"/>
    <id>http://yoursite.com/diary/javascript-design-pattern1/</id>
    <published>2017-08-03T09:28:33.495Z</published>
    <updated>2017-08-08T09:25:19.775Z</updated>
    
    <content type="html"><![CDATA[<p>从事前端有两年的时间了，一直觉得自己只致力于实践而忽视了理论上的知识，所以现在想边看《javascript设计模式与开发实践》这本书的同时边记录下自己的学习与理解。刚开始写自己的博文，嗯。。。不怎么会组织文字。。。还是快点开始正文吧^^</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-What-is-设计模式？"><a href="#1-What-is-设计模式？" class="headerlink" title="1.What is 设计模式？"></a>1.What is 设计模式？</h3><p>设计模式其主要思想就是面向对象编程，即不在乎你是谁（is-A），而在于你可以做什么（Has-A）。就像你不必知道电视机里面有些什么、怎么焊接。。。你只要使用发明者提供给你的按钮或遥控器来使用它，就ok了。</p>

<h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h3><p>设计模式主要是使用封装、继承、多态、组合等技术实现，而对象多态性的概念是其重要的基本编程思想。</p>

<h4 id="2-1what-is-多态？"><a href="#2-1what-is-多态？" class="headerlink" title="2.1what is 多态？"></a>2.1what is 多态？</h4><p>多态，其根本就是将过程化的条件语句变成对象的多种状态设定。举个栗子：</p>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span>(<span class="params">person</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(person <span class="keyword">instanceof</span> person1)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'小明'</span>);</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(person <span class="keyword">instanceof</span> person2)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'小红'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">showName(<span class="keyword">new</span> person1); <span class="comment">//小明</span></div><div class="line">showName(<span class="keyword">new</span> person2); <span class="comment">//小红</span></div></pre></td></tr></table></figure>
<p>从上面的代码可以看到，我们通过if…else if语句判断是哪个人，再打印出他相对应的名字。那么当需要增添其他人的时候，我们就需要修改showName方法，或许你也觉得这没什么，但是当我们还有showAge、showSex等等的方法的时候，每增添多一个人就需要同时修改N多的方法，这样并不利于代码的维护性，也增加了自己的工作量。</p>

<p>那就来看看利用对象多态特性的写法吧</p>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'小明'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'小红'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span>(<span class="params">person</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(person.name?person.name: <span class="string">'他没有名字'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">showName(<span class="keyword">new</span> person1); <span class="comment">//小明</span></div><div class="line">showName(<span class="keyword">new</span> person2); <span class="comment">//小红</span></div></pre></td></tr></table></figure>
<p>上面的代码中，showName方法根本不用判断你是‘小明’还是‘小红’，它只负责显示对象的‘name’这一个属性，而name就是对象的其中一个状态表示，即使新增N个人，只要他拥有‘name’这个属性他就能显示出来，管理人员的人并不需要知道showName这个方法内部是如何运作。</p>

<h4 id="Ps"><a href="#Ps" class="headerlink" title="Ps"></a>Ps</h4><p>js是一种动态语言，他没有类型检查，这对于利用对象多态特性进行编程来说十分的便利。而静态语言，在实现这种方式编程中不可避免的要经过类型检查这个关卡(本人觉得这是个非常蛋疼的过程)。静态语言实现方式在这里就不多讲了，有兴趣的人可以去看看《javascript设计模式与开发实践》中1.2.3节的介绍…^^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从事前端有两年的时间了，一直觉得自己只致力于实践而忽视了理论上的知识，所以现在想边看《javascript设计模式与开发实践》这本书的同时边记录下自己的学习与理解。刚开始写自己的博文，嗯。。。不怎么会组织文字。。。还是快点开始正文吧^^&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a
    
    </summary>
    
    
  </entry>
  
</feed>
